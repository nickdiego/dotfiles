# vim:ft=sh:

_proj_dir=~/projects

unset -v _prev_project _projects
declare -a _projects _prev_project

# Helper functions
config_proj() {
  function generate_proj_env() {
    local projname=$1 projpath=$2 subproj
    eval "${projname}_proj_root=$projpath"
    if declared_func setenv; then
      eval "${projname}_setenv() {
        $(declare -f setenv)
        projname=$projname
        projroot=$projpath
        declare -Ag dirs=( [root]=${projpath} )
        setenv \$@
      }"
      local subs=( $projname ${subprojects[@]} )
      for subproj in ${subs[@]}; do
        ${projname}_setenv $subproj
        generate_subproj_env $projname $projpath $subproj
      done
    fi
  }

  function generate_subproj_env() {
    local projname=$1 projpath=$2 subproj=$3
    local d prefix=$(generate_prefix $projname $subproj)
    declare -Ag ${prefix}_dirs
    for d in "${!dirs[@]}"; do
      eval "${prefix}_dirs[$d]=${dirs[$d]}"
    done
    eval "${prefix}_defaultdir=${defaultdir}"
    eval "${prefix}_targets=(${targets[@]})"
    eval "${prefix}_options=(${options[@]})"
    if ! declared_func 'activate'; then
      eval "${prefix}_set_as_curr_project() {
        ${projname}_setenv '$subproj'
      }"
    else
      eval "${prefix}_set_as_curr_project() {
        $(declare -f activate)
        ${projname}_setenv '$subproj'
        activate '${subproj}' \$@
      }"
    fi
    _projects+=( $(generate_prefix $projname $subproj '/') )
    clear_subproj_env
  }

  function generate_prefix() {
    local proj=$1 sub=$2 sep=${3:-_}
    [ "$proj" = "$sub" ] && echo $proj || echo "${proj}${sep}${sub}"
  }

  function clear_proj_env() {
     unset -v projname projpath projroot subprojects targets
     unset -f setenv activate
  }

  function clear_subproj_env() {
     unset -v dirs defaultdir target options vimsession
  }

  function declared_func() {
    declare -f "$1" >/dev/null
  }

  local script=$1
  source $script
  if [[ -z $projname ]]; then
    log_message "Error: Couldn't find \$projname for $script"
    return 1
  else
    local projrootpath=${projpath:-$_proj_dir/$projname}
    test -d $projrootpath || return 1
    log_message "Setting env for $projrootpath"
    generate_proj_env $projname $projrootpath
    clear_proj_env
  fi
}

# Internal helper functions
log_message() {
  (( ${_opt['-v']} )) && echo $@
}

# TODO For now supports only boolean
# params. Improve it later
# TODO implement _extraargs, for args
# after "--", if present
process_args() {
  declare -a vals opts
  while (( $# )); do
    case $1 in
      -?)
        opts+=("[${1}]=1")
        ;;
      --*)
        opts+=("[${1}]=1")
        ;;
      *)
        vals+=( $1 )
    esac
    shift
  done
  echo "declare -a _val=(${vals[@]});"
  echo "declare -A _opt=(${opts[@]});"
}

clear_curr_proj_vars() {
  local varname
  for varname in "${!curr_proj*}"; do
    unset -v ${varname}
  done
}

## Public functions
set_project() {
  eval $(process_args $@)
  local projid=${_val[0]}
  if [ "$projid" = "-" ] || (( ${_opt['--back']} )); then
    local last=$((${#_prev_project[@]} - 1))
    if (( $last < 0 )); then
      echo "No previous project set."
      return 1
    fi
    _opt['--back']=1
    projid=${_prev_project[$last]}
    unset -v _prev_project[$last]
  fi

  local subproj=${projid#*/}
  local prefix=${projid/\//\_}
  local activatefunc=${prefix}_set_as_curr_project
  if [[ "$projid" != "$curr_project" && "${_opt['--back']}" -ne 1 ]]; then
    _prev_project+=($curr_project)
  fi

  clear_curr_proj_vars
  declared_func $activatefunc && $activatefunc $subproj
  local d dirnames=("${!dirs[@]}")
  if (( ${#dirnames[@]} )); then
    for d in ${dirnames[@]}; do
      eval "curr_proj_${d}_dir=${dirs[${d}]}"
    done
    curr_proj_dir=${dirs[${defaultdir:-src}]}
  fi

  curr_proj_target=$target
  curr_proj_vimsession=${vimsession:-$subproj}
  curr_project=$projid
  clear_subproj_env

  log_message "Switched ${_opt['--back']:+back }to project '${projid}'" \
    " (Back stack: [ $(sed 's/ / > /g' <<< "${_prev_project[@]}") ])"
}

cd_project() {
  eval $(process_args $@)
  local projid=${_val[0]:-$curr_project}
  set_project $projid ${!_opt[@]}
  cd $curr_proj_dir
}

## Bash completion stuff
__projectopts() {
  #(( ${#_projects[@]:-0} )) || return 0
  local i=1 cur="${COMP_WORDS[COMP_CWORD]}"
  local optset=() result=()
  local arg proj
  while (( i < COMP_CWORD )); do
    arg=${COMP_WORDS[i]}
    case $arg in
      --* | -?) optset+=( $arg );;
      *) [[ "${_projects[@]}" =~ "${arg}" ]] && proj=${arg/\//_}
        ;;
    esac
    i=$((i+1))
  done
  if [[ -z ${proj:-} ]]; then
    result+=( "${_projects[*]}" )
  else
    result+=( "$_cmdproj_options" "\${${proj}_options[@]}" )
  fi
  COMPREPLY=( $(compgen -W "${result[*]}" -- ${cur}) )
  return 0
}

## Init stuff
_cmdproj_options=( '-v' )

if [ -d ~/.projects-env.d ]; then
  for script in ~/.projects-env.d/*.sh; do
    config_proj $script
  done
  unset script
fi

complete -F __projectopts set_project
complete -F __projectopts cd_project

## Aliases
alias pset='set_project'
alias pcd='cd_project'
complete -F __projectopts pset
complete -F __projectopts pcd

