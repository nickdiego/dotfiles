# vim:ft=sh:

_proj_dir=~/projects

declare -a _projects _prev_project
declare -A _argopts

# Helper functions

config_proj() {

  function generate_proj_env() {
    local projname=$1 projpath=$2 subproj
    eval "${projname}_proj_root=$projpath"
    if declared_func setenv; then
      eval "${projname}_setenv() {
        $(declare -f setenv)
        projname=$projname
        projroot=$projpath
        setenv \$@
      }"
      local subs=${subprojects[@]:-$projname}
      for subproj in $subs; do
        ${projname}_setenv $subproj
        generate_subproj_env $projname $projpath $subproj
      done
    fi
  }

  function generate_subproj_env() {
    local projname=$1 projpath=$2 subproj=$3
    local prefix=$(generate_prefix $projname $subproj)
    eval "${prefix}_src_dir=${srcdir}"
    eval "${prefix}_targets=(${targets[@]})"
    eval "${prefix}_options=(${options[@]})"
    if declared_func 'activate'; then
      eval "${prefix}_set_as_curr_project() {
        $(declare -f activate)
        ${projname}_setenv '$subproj'
        activate '${subproj}' \$@
      }"
      _projects+=(${prefix/\_/\/})
    fi
    clear_subproj_env
  }

  function generate_prefix() {
    local proj=$1 sub=$2
    [ "$proj" = "$sub" ] && echo $proj || echo "${proj}_${sub}"
  }

  function clear_proj_env() {
     unset -v projname projroot subprojects targets
     unset -f setenv activate
  }

  function clear_subproj_env() {
     unset -v srcdir builddir target
     # TODO unset functions?
  }

  function declared_func() {
    declare -f "$1" >/dev/null
  }

  local script=$1
  source $script
  if [[ -z $projname ]]; then
    log_message "Error: Couldn't find \$projname for $script"
    return 1
  else
    local projpath=$_proj_dir/$projname
    test -d $projpath || return 1
    log_message "Setting env for $projpath"
    generate_proj_env $projname $projpath
    clear_proj_env
  fi
}

# Internal helper functions
log_message() {
  (( ${_opt['-v']} )) && echo $@
}

# TODO For now supports only boolean
# params. Improve it later
# TODO implement _extraargs, for args
# after "--", if present
process_args() {
  declare -a vals opts
  while (( $# )); do
    case $1 in
      -?)
        opts+=("[${1}]=1")
        ;;
      --*)
        opts+=("[${1}]=1")
        ;;
      *)
        vals+=( $1 )
    esac
    shift
  done
  echo "declare -a _val=(${vals[@]});"
  echo "declare -A _opt=(${opts[@]});"
}

## Public functions
set_project() {
  eval $(process_args $@)
  local projid=${_val[0]}
  if [ "$projid" = "-" ] || (( ${_opt['--back']} )); then
    local last=$((${#_prev_project[@]} - 1))
    if (( $last < 0 )); then
      echo "No previous project set."
      return 1
    fi
    _opt['--back']=1
    projid=${_prev_project[$last]}
    unset -v _prev_project[$last]
  fi

  local prefix=${projid/\//\_}
  local activatefunc=${prefix}_set_as_curr_project
  if ! declared_func $activatefunc; then
    echo "Error: Project '$projid' not found!"
    return 1
  fi
  if [[ "$projid" != "$curr_project" && "${_opt['--back']}" -ne 1 ]]; then
    _prev_project+=($curr_project)
  fi
  $activatefunc ${projid#*/}
  curr_project=$projid
  curr_proj_src_dir=$srcdir
  curr_proj_build_dir=$builddir
  curr_proj_target=$target
  clear_subproj_env

  log_message "Switched${_opt['--back']:+ back} to project '${projid}'"\
    " (Back stack: [ ${_prev_project[@]//' '/\<\-} ])"
}

cd_project() {
  eval $(process_args $@)
  local projid=${_val[0]:-$curr_project}
  set_project $projid ${!_opt[@]}
  cd $curr_proj_src_dir
}

if [ -d ~/.projects-env.d ]; then
  for script in ~/.projects-env.d/*.sh; do
    config_proj $script
  done
  _prev_project=()
  unset script
fi

## Bash completion stuff
__available_projects() {
  local cur prev projects

  cur="${COMP_WORDS[COMP_CWORD]}"
  prev="${COMP_WORDS[COMP_CWORD-1]}"
  projects="${_projects[@]}"

  COMPREPLY=( $(compgen -W "${projects}" -- ${cur}) )
  return 0
}

complete -F __available_projects set_project
complete -F __available_projects cd_project
