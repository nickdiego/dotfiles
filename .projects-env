# vim:ft=sh:

# Set $verbose_env var to see debug messages
# from env scripts
verbose_env=n

_proj_dir=~/projects
_projects=()

_prev_project=()

# Helper functions

config_proj() {

  function generate_proj_env() {
    local projname=$1 projpath=$2 subproj
    eval "${projname}_proj_root=$projpath"
    if declared_func setenv; then
      eval "${projname}_setenv() {
        $(declare -f setenv)
        projroot=$projpath
        setenv \$@
      }"
      local subs=${subprojects[@]:-$projname}
      for subproj in $subs; do
        ${projname}_setenv $subproj
        generate_subproj_env $projname $projpath $subproj
      done
    fi
  }

  function generate_subproj_env() {
    local projname=$1 projpath=$2 subproj=$3
    local prefix=$(generate_prefix $projname $subproj)
    eval "${prefix}_src_dir=${srcdir}"
    eval "${prefix}_targets=(${targets[@]})"
    if declared_func 'activate'; then
      eval "${prefix}_set_as_curr_project() {
        $(declare -f activate)
        ${projname}_setenv '$subproj'
        activate '${subproj}' \$@
      }"
      _projects+=(${prefix/\_/\/})
    fi
    clear_subproj_env
  }

  function generate_prefix() {
    local proj=$1 sub=$2
    [ "$proj" = "$sub" ] && echo $proj || echo "${proj}_${sub}"
  }

  function clear_proj_env() {
     unset -v projname projroot subprojects targets
     unset -f setenv activate
  }

  function clear_subproj_env() {
     unset -v srcdir builddir target
     # TODO unset functions?
  }

  function declared_func() {
    declare -f "$1" >/dev/null
  }

  function log_message() {
    [[ $verbose_env = 'y' ]] && echo $@
  }

  local script=$1

  source $script
  if [[ -z $projname ]]; then
    log_message "Error: Couldn't find \$projname for $script"
    return 1
  else
    local projpath=$_proj_dir/$projname
    test -d $projpath || return 1
    log_message "Setting env for $projpath"
    generate_proj_env $projname $projpath
    clear_proj_env
  fi
}


## Public functions
set_curr_project() {
  local projname=$1 local prefix=${1/\//\_}
  local activatefunc=${prefix}_set_as_curr_project
  if ! declared_func $activatefunc; then
    echo "Error: Project '$projname' not found!"
    return 1
  fi
  shift && $activatefunc $@
  (( _backing )) || _prev_project+=($curr_project)
  export curr_project=$projname
  export curr_proj_build_dir=$builddir
  export curr_proj_target=$target
  clear_subproj_env
}

cd_project() {
  local projname=${1:-$curr_project}
  local prefix=${projname/\//\_}
  case $projname in
    -)
      local last=$((${#_prev_project[@]} - 1))
      if (( $last < 0 )); then
        echo "No previous project set."
      else
        _backing=1 cd_project ${_prev_project[$last]}
        unset -v _prev_project[$last] _backing
      fi
      ;;
    *)
      if [ "$projname" != "$curr_project" ]; then
        shift && set_curr_project $projname $@
      fi
      eval "pushd \${${prefix}_src_dir} >/dev/null"
      ;;
  esac
}

if [ -d ~/.projects-env.d ]; then
  for script in ~/.projects-env.d/*.sh; do
    config_proj $script
  done
  unset script
fi

## Bash completion stuff
__available_projects() {
  local cur prev projects

  cur="${COMP_WORDS[COMP_CWORD]}"
  prev="${COMP_WORDS[COMP_CWORD-1]}"
  projects="${_projects[@]}"

  COMPREPLY=( $(compgen -W "${projects}" -- ${cur}) )
  return 0
}

complete -F __available_projects set_curr_project
complete -F __available_projects cd_project

unset -v verbose_env
