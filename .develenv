## Random useful stuff
alias ls='ls --color'

PROXY_INDT=172.18.216.7

#PS1="\033]0;${PWD}\n\033[32m${USER}@${HOSTNAME} \033[33m${PWD/${HOME}/~}$ "
alias vncn9="vncviewer ${N92_IP}:0"
alias ssh-clean='rm ~/.ssh/known_hosts'
alias pixeltool='/home/nick/Programs/QtSdk/Desktop/Qt/474/gcc/bin/pixeltool'
alias psgrep='ps aux | grep '
alias fgrep='find|grep --exclude="*~" --exclude="*.swp"'
alias sendpatch='arc diff --reviewers lmoura,tullio,luck,hugopl,dakerfp,lacerda,setanta,sergio,zanoni HEAD~1'
alias reattach-tmux='tmux attach -tprogramming'

export ZBAR=/home/nick/apm-2012/apps/buscape/zbar-0.10
export BUSCAPE=/home/nick/apm-2012/apps/buscape/git-repo/searchfoot
alias zxing=/home/nick/apm-2012/apps/buscape/zxing-2.0/cpp/build/zxing
alias zbarimg=/home/nick/apm-2012/apps/buscape/zbar-0.10/build/zbarimg/zbarimg

export EDITOR=vim
export VISUAL=vim
export NODE_PATH=/usr/local/lib/node_modules

export MUCURA="nick@mucura.local"
export PATH=~/bin:$PATH

#icecc_setup
export USE_SCHEDULER=10.60.69.53
function icecc_setup {
  #export ICECC_VERSION=$HOME/.icecc/linux-x86_64-gcc4.6.3-x86_64.tar.gz
  #export ICECC_VERSION=$HOME/.icecc/linux-x86_64-gcc4.8.1-x86_64.tar.gz
  export ICECC_VERSION=$HOME/.icecc/linux-x86_64-gcc4.7.3-x86_64.tar.gz
  export CCACHE_PREFIX=icecc
  for i in gcc g++ cc c++; do
    ln -sf /usr/bin/ccache $HOME/bin/$i
  done
}

#nix-related
WEBKIT=$HOME/projects/webkit-nix
if [ -f $WEBKIT/nix-env.sh ]; then
  export WEBKIT
  . $WEBKIT/nix-env.sh
fi

#alias vim='vim -c "set columns=$COLUMNS"'
export RPI_NICK=pi@10.60.69.52

#alias vim='vim -c "set columns=$COLUMNS"'
alias ssh-diegoyam-server='ssh server-amazon -i ~/key_amazon_server.pem'

# Create a ssh reverse tunnel to my amazon cloud server
reverse_tunnel_server() {
  ssh -R 30000:localhost:22 server-amazon
}

export PATH=$HOME/local/bin:$PATH

# When using git-svn to manipulate a svn repo
# through git tool, the SVN tags are not automatically
# imported as GIT tags, instead, the svn tagas are
# initially git remote branches
#
# This functions tranforms those svn tags in actual
# git tags
git_import_svn_tags()  {
  if [ "x$1" = "x--do-it" ]; then
    DO_IT=1
  fi

  git for-each-ref --format="%(refname:short) %(objectname)" refs/remotes/tags |
  while read BRANCH REF; do
    TAG_NAME=${BRANCH#*/}
    BODY="$(git log -1 --format=%s $REF)"
    #echo "ref=[$REF] parent=[$(git rev-parse $REF^)] tagname=[$TAG_NAME] branch=[$BRANCH]" >&2

    echo "git tag -a -m \"$BODY\" $TAG_NAME $REF^"
    echo "git branch -r -d $BRANCH"
    if [ ! -z $DO_IT ]; then
      git tag -a -m "$BODY" $TAG_NAME $REF^
      git branch -r -d $BRANCH
    fi
  done

  if [ -z $DO_IT ]; then
    echo ##################################
    echo Only showing what to do!
    echo To actually do that run: $0 --do-it
    echo ##################################
  fi
}

# git completion in Arch
if [ -f /usr/share/git/completion/git-completion.bash ]; then
  . /usr/share/git/completion/git-completion.bash
fi

# Enables a (already xrandr configured) second monitor,
# to see current configured outputs:
#
# $ xrandr -q
#
# usage: enable_display [<XRANDR_OUTPUT_ID>]
export DISPLAY_MAIN='LVDS1'
export DISPLAY_AUX='VGA1'

enable_aux_display() {
  xrandr --output $DISPLAY_AUX --auto --primary --above $DISPLAY_MAIN
}

enable_main_display() {
  xrandr --output $DISPLAY_MAIN --auto --below $DISPLAY_AUX
}

disable_display() {
  OUTPUT_ID=$1
  [ -z $OUTPUT_ID ] && OUTPUT_ID=$DISPLAY_AUX
  xrandr --output $OUTPUT_ID --off
}

fix_resolution_main_monitor() {
  xrandr --output $DISPLAY_MAIN --auto --primary
}

set_main_monitor() {
  OUTPUT_ID=$1
  xrandr --output $OUTPUT_ID --primary
}

set_left_as_main_monitor() {
  set_main_monitor $DISPLAY_AUX
}

set_right_as_main_monitor() {
  set_main_monitor $DISPLAY_MAIN
}

start_aux_monitor() {
  enable_aux_display && sleep 1
  disable_display $DISPLAY_MAIN && sleep 1
  enable_main_display
}

reset_findsrc_dir() {
    export FINDSRC_DIR='.'
}
reset_findsrc_dir

findsrc() {
    DIR='.'
    [ -z $FINDSRC_DIR ] && DIR=$PWD
    find $DIR | grep "$1.c\$\|$1.cpp\$\|$1.h\$"
}

grepsrc() {
    grep $@ `find -name "*[.cpp,.h]"`
}

export POWERLINE_PATH="$HOME/.local/lib/python2.7/site-packages/powerline"
#. $POWERLINE_PATH/bindings/bash/powerline.sh

# replacing something in several files
#cat /tmp/xxxxx | xargs -I '{}' sed -i 's/RenderPartObject {IFRAME}/RenderIFrame {IFRAME}/g' {}

alias grep="grep --exclude='*~' --exclude='*.swp'"
alias remove_colors='sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGK]//g"'
alias pjson='json | pygmentize -l json'

# open vim session
v() {
  local arg=`test -z $1 || echo -S ~/.vim/sessions/$1`
  vim $arg
}

_vim_sessions() {
  local cur prev sessions

  cur="${COMP_WORDS[COMP_CWORD]}"
  prev="${COMP_WORDS[COMP_CWORD-1]}"
  sessions=$([ -d ~/.vim/sessions ] && basename -a `ls ~/.vim/sessions`)

  COMPREPLY=( $(compgen -W "${sessions}" -- ${cur}) )
  return 0
}

complete -F _vim_sessions v

remove_from_path() {
  local p d dirs
  dirs=$@
  for d in $dirs; do
    p=`echo $PATH | sed -e "s,:$d,,"`
    export PATH=$p
  done
}

# Set $verbose_env var to see debug messages
# from env scripts
#verbose_env=on
tools_dir=$HOME/devtools
if [ -d ~/.tools-env.d ]; then
  for env_script in ~/.tools-env.d/*.sh; do
    if [ -r $env_script ]; then
      . $env_script
    fi
  done
  unset i
fi

proj_dir=$HOME/projects
if [ -d ~/.projects-env.d ]; then
  for env_script in ~/.projects-env.d/*.sh; do
    if [ -r $env_script ]; then
      . $env_script
    fi
  done
  unset i
fi

unset tools_dir
unset proj_dir
