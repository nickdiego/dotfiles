# Development env helpers (vars,
# functions, workarounds, aliases,
# plugins, etc..
export EDITOR=vim
export VISUAL=vim
export MAIL=/var/spool/mail/nick
export FIGNORE='.swp:.un~'
export CUSTOM_GREP_OPTIONS=('--exclude=*~' '--exclude=*.swp')

export PATH=~/.bin:~/local/bin:$PATH

#TODO move to .projects-env.d/nix.sh
#nix-related
WEBKIT=$HOME/projects/webkit-nix
if [ -f $WEBKIT/nix-env.sh ]; then
  export WEBKIT
  . $WEBKIT/nix-env.sh
fi

# work around some term/vim issues with window resizing
#alias vim='vim -c "set columns=$COLUMNS"'

alias ssh-diegoyam-server='ssh server-amazon -i ~/key_amazon_server.pem'
# Create a ssh reverse tunnel to my amazon cloud server
reverse_tunnel_server() {
  ssh -R 30000:localhost:22 server-amazon
}

# When using git-svn to manipulate a svn repo
# through git tool, the SVN tags are not automatically
# imported as GIT tags, instead, the svn tagas are
# initially git remote branches
#
# This functions tranforms those svn tags in actual
# git tags
git_import_svn_tags()  {
  if [ "x$1" = "x--do-it" ]; then
    DO_IT=1
  fi

  git for-each-ref --format="%(refname:short) %(objectname)" refs/remotes/tags |
  while read BRANCH REF; do
    TAG_NAME=${BRANCH#*/}
    BODY="$(git log -1 --format=%s $REF)"
    #echo "ref=[$REF] parent=[$(git rev-parse $REF^)] tagname=[$TAG_NAME] branch=[$BRANCH]" >&2

    echo "git tag -a -m \"$BODY\" $TAG_NAME $REF^"
    echo "git branch -r -d $BRANCH"
    if [ ! -z $DO_IT ]; then
      git tag -a -m "$BODY" $TAG_NAME $REF^
      git branch -r -d $BRANCH
    fi
  done

  if [ -z $DO_IT ]; then
    echo ##################################
    echo Only showing what to do!
    echo To actually do that run: $0 --do-it
    echo ##################################
  fi
}

# git completion in Arch
if [ -f /usr/share/git/completion/git-completion.bash ]; then
  . /usr/share/git/completion/git-completion.bash
fi

# Multihead helper functions
# To see current display config, execute:
# $ xrandr -q

# Running Wayland
if [ ! -z $WAYLAND_DISPLAY ]; then
  export DISPLAY_MAIN='XWAYLAND0'
  export DISPLAY_AUX='XWAYLAND1'
  export DISPLAY_AUX='XWAYLAND2'
else # assuming Running Xorg
  export DISPLAY_MAIN='LVDS1'
  export DISPLAY_AUX1='VGA1'
  export DISPLAY_AUX2='HDMI1'
fi

add-display-mode() {
  local hres=${1:-1440} vres=${2:-900}
  local name=${3:-"${hres}x${vres}_custom"}
  local mode=$(cvt $hres $vres | tail -n1 | sed 's,^Modeline ".\+"\s\+,,')
  xrandr --newmode "$name" $mode 2>/dev/null || return 1
}

add-aux-display-modes() {
  local modename=$1
  add-display-mode 1440 900 "$modename" &&
  xrandr --addmode $DISPLAY_AUX1 "$modename" &&
  xrandr --addmode $DISPLAY_AUX2 "$modename"
}

arrange-displays() {
  local modename='1440x900_aux'
  add-aux-display-modes "$modename"
  case $1 in
    -0 | --reset)
      xrandr --output $DISPLAY_AUX2 --off \
        --output $DISPLAY_AUX1 --off \
        --output $DISPLAY_MAIN --auto;;
    -2)
      xrandr --output $DISPLAY_MAIN --off \
        --output $DISPLAY_AUX2 --left-of $DISPLAY_AUX1 --mode "$modename" --primary \
        --output $DISPLAY_AUX1 --mode "$modename";;
    -3 | '')
      xrandr --output $DISPLAY_AUX2 --mode "$modename" --left-of $DISPLAY_AUX1 \
        --output $DISPLAY_AUX1 --mode "$modename" --left-of $DISPLAY_MAIN \
        --output $DISPLAY_MAIN --auto;;
  esac
}

add-big-display-modes() {
  local modename=$1
  add-display-mode 1440 818 "$modename" &&
  xrandr --addmode VGA1 "$modename"
}

arrange-displays2() {
  local modename='aux27'
  add-big-display-modes "$modename"
  case $1 in
    -0 | --reset)
      xrandr --output VGA1 --off \
        --output $DISPLAY_MAIN --auto;;
    -2 | '')
      #local mode="--mode $modename"
      local mode="--auto"
      xrandr --output VGA1 $mode --left-of $DISPLAY_MAIN \
        --output $DISPLAY_MAIN --auto;;
  esac
}

# Find/Grep src helper functions
reset_findsrc_dir() {
  export FINDSRC_DIR='.'
}

findsrc() {
  DIR='.'
  [ -z $FINDSRC_DIR ] && DIR=$PWD
  find $DIR | grep "$1.c\$\|$1.cpp\$\|$1.h\$"
}

grepsrc() {
  grep $@ `find -name "*[.cpp,.h]"`
}

reset_findsrc_dir

export POWERLINE_PATH="$HOME/.local/lib/python2.7/site-packages/powerline"
#. $POWERLINE_PATH/bindings/bash/powerline.sh

# replacing something in several files
#cat /tmp/xxxxx | xargs -I '{}' sed -i 's/RenderPartObject {IFRAME}/RenderIFrame {IFRAME}/g' {}

alias remove_colors='sed -r "s/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[mGK]//g"'
alias pjson='json | pygmentize -l json'

# open vim session
v() {
  local session=${1:-${curr_proj_vimsession}}

  if [[ -z $session ]]; then
    echo "No session passed as argument nor \$curr_proj_vimsession set!" >&2
    return 1
  fi

  eval "vim '+SessionOpen $session' '+set columns=$COLUMNS'"
}

_vim_sessions() {
  local cur prev sessions

  cur="${COMP_WORDS[COMP_CWORD]}"
  prev="${COMP_WORDS[COMP_CWORD-1]}"
  sessions=$([ -d ~/.vim/sessions ] && basename -a `ls ~/.vim/sessions`)

  COMPREPLY=( $(compgen -W "${sessions}" -- ${cur}) )
  return 0
}

complete -F _vim_sessions v

remove_from_path() {
  local p d dirs
  dirs=$@
  for d in $dirs; do
    p=`echo $PATH | sed -e "s,:$d,,"`
    export PATH=$p
  done
}

take-screenshot() {
  local outdir=${1:-$HOME/Pictures}
  local filename="${2:-screenshot-`date +'%b-%d-%y_%H:%M:%S'`}.jpg"
  local file="${outdir}/${filename}"
  echo "## Select the screen region."
  echo "## Will save it in $file"
  gm import "$file" && nautilus "$file"&
}

get_external_ip() {
  curl -s http://whatismyip.org/ | grep -oP '(\d{1,3}\.){3}\d+'
}

bashrc-reload() {
  source ~/.bashrc
}

alias load-ssh-keys='eval "$(ssh-agent -s)" && ssh-add ~/.ssh/id_rsa_2016'
alias image-dimensions="identify -format \"%i -> %w x %h\n\" $@"

pac() {
  local needs_sudo=0
  for arg in $@; do
    case $arg in
      -S | -R | -Rs | -Syu)
        needs_sudo=1
        ;;
    esac
  done
  if (( $needs_sudo )); then
    sudo pacman $@
  else
    pacman $@
  fi
}

check_shared_lib() {
  ldd -r $1
}

alias i='pac -S'
alias s='pac -Ss'
alias r='pac -R'
alias rr='pac -Rs'
alias u='pac -Syu'

trust-key() {
  local key=$1
  gpg --recv-key $key
  gpg --lsign $key
}

set-window-title() {
  test -n $TMUX && tmux rename-window "$1"
  which wmctrl >/dev/null || { echo "Error! 'wmctrl' not installed!";  return 1; }
  DISPLAY=':0' wmctrl -r :ACTIVE: -N "$1"
}

custom_find() {
  declare -a opts
  while (( $# )); do
    case "$1" in
      '-n') opts+=( '-name' );;
      *) opts+=( "$1" );;
    esac
    shift
  done
  echo find "${opts[@]}"
}

#TODO not working yet
#alias f='custom_find'
#complete -F _find f

find_in_jars() {
  local keyword=$1
  local dir=$2 i
  for i in $(find ${dir} -name '*.jar'); do
    echo "----- jarfile: $i"
    unzip -l $i | grep --color $keyword
  done
} && alias fj='find_in_jars'

## Projects confs

[ -f ~/.tools-env ] && . ~/.tools-env
[ -f ~/.projects-env ] && . ~/.projects-env
#set_project @knockout
set_project @drunk/client &>/dev/null

export ethernet='enp1s0'
export wlan='wlp2s0'

udpate_cups_ppd_file() {
  echo "## Updating ppd files..."
  sudo /usr/bin/cups-genppdupdate &&
  echo "## Restarting cuspsd service..."
  sudo systemctl restart org.cups.cupsd.service
}

# ex: ts=2 sw=2 et filetype=sh
